---
title: "Project title + year"
author: "Jouni Vatanen"
date: "`r format(Sys.time(), '%d.%m.%Y')`"
output: 
  html_document: 
    toc: TRUE
    toc_depth: 2
    number_sections: FALSE
    df_print: paged
    code_folding: hide
    css: "./doc/Ilmarinen.css"
editor_options: 
  chunk_output_type: console
---

```{r create-html-document, eval = FALSE}
# Activate to run results and create a html file
rmarkdown::render("Project-name-year-v1.Rmd", output_dir = "./output")
```

```{r setup, echo = FALSE, warning = FALSE, message = FALSE}
# DEFINE PATHS
if (!require("fs")) install.packages("fs"); library(fs)
d_src <- path("./R")
d_data <- path("./data")
d_out <- path("./output")

# LOAD PACKAGES AND FUNCTIONS
# Create required packages file for the checkpoint
packages <- c(
  "extrafont", "readxl", "tidyverse", "vroom", "lubridate", "stringi", "janitor"
  #, "quantmod", "magrittr", "seasonal", "xts", "zoo"
  #, "modelr", "broom", "caret"
  #, "grid", "gridExtra", "DT", "tm", "wordcloud", "SnowballC",
  #, "keyring", "DBI", "httr", "XML", "jsonlite", "rvest"
  #, "GGally", "kableExtra", "FactoMineR", "factoextra", "ClustOfVar"
  #, "ggrepel", "pROC", "webshot", "psych", "htmlwidgets", "rJava"
  )
cat(sprintf("library(%s, warn.conflicts=FALSE)", packages), 
    file = path(d_src, "packages.R"), sep = "\n")

# Checkpoint installs packages
if (!require("checkpoint")) install.packages("checkpoint")
# use a date few weeks after R.version was released
checkpoint::checkpoint("2020-04-26", R.version = "4.0.0", 
                       checkpointLocation = Sys.getenv("USERPROFILE"))

# Load usual packages, custom functions for the project and general functions
source(path(d_src, "packages.R"))
source(path(d_src, "functions.R"))
devtools::install_github("JouniVatanen/stools", upgrade = F); library(stools)
# Note: Need a permission and GITHUB_PAT
#devtools::install_github("JouniVatanen/itools"); library(itools)
# Note: Needed only, if you want to send emails from work network
#devtools::install_github("omegahat/RDCOMClient"); library(RDCOMClient)

# Executes only if rJava is loaded for it to work properly
if ("rJava" %in% .packages()) {
  # Choose your Java path
  java_path <- path(Sys.getenv("USERPROFILE"), "Tools/Java/jre")
  # Set Java path if it exists
  if (dir_exists(java_path)) options(java.home = java_path)
  else stop("Define correct path for Java in java.path")
}

# GENERAL OPTIONS AND VARIABLES
# Load data from stools package
#data("fi_postnumber_2020", package = "stools")
#data("fi_people_names", package = "stools")
#data("fi_industries_2008", package = "stools")

# Check if Arial fonts are installed and install, if they are not
if (!any(match(fonts(), "Arial"), na.rm = TRUE)) {
  font_import(pattern = "arial.*", prompt = FALSE)
}

# Set knitr options like NA values for tables and locale
knitr::opts_chunk$set(warning = F, message = F, echo = F)
options(knitr.kable.NA = "", scipen = 999)

# Change options eg. match Finnish locale
fi_locale <- locale(date_names = "fi", decimal_mark = ",", grouping_mark = " ")
na_values <- c("", "NA", "-'")

# Use keyring, if it is loaded
if ("keyring" %in% .packages()) {
  # Set variables to be used in keyring.
  kr_service <- "my_service"
  kr_username <- "my_username"

  # If keyring service is not yet defined, then define password
  if (is.na(key_list(kr_service)[1, 2])) {
    warning("Check the kr_username and save your password to keyring")
    key_set(service = kr_service, username = kr_username)
  }
}
```

# Johdanto

Miksi tämä työ on tehty ja joitain tarvittavia linkkejä

```{r load-data-from-file, eval = FALSE}
# Load data
# Load single csv
df <- fread(path(d_data, "data.csv"), select = col_select, encoding = "UTF-8") %>%
  clean_names
  
# Load single xls/xlsx sheet
df <- read_excel(path(d_data, "data.xlsx")) %>%
  clean_names

# Load multiple xls/xlsx sheets
# Choose sheet names or numbers and load using purr
df <- c("Sheet 1", "Sheet 2", "Sheet 3") %>%
  map_df(~read_excel(path(d_data, "data.xlsx"), sheet = .x)) %>%
  clean_names

# Load multiple xls/xlsx files
# Choose patterns for file names and load using purrr
df <- dir_ls(d_data, glob = "Osallistujat.*") %>%
  map_df(~read_excel(.x)) %>%
  clean_names

```

```{r load-data-from-db, eval = FALSE}
# Connect to db
# Note: use encoding = "latin1" to some databases
con <- dbConnect(odbc::odbc(), dsn = "odbc_connection_name")

# Create queries
sql <- glue_sql(
  "SELECT *
  FROM database
  ", .con = con)

# Get data and disconnect
df_db <- dbGetQuery(con, sql) %>% clean_names()
dbDisconnect(con)

```

```{r mutate-data, eval = FALSE}
# Mutate data
# Create a data that contains all the open feedback
df_feedback <- df %>%
  select() %>%
  mutate_all(~if_else(.x %in% c(
    "Kyllä, missä asioissa?", 
    "En, mitä tietoa kaipasit?", 
    "Kyllä", 
    "En",
    "Jollain muulla tavalla, miten?", 
    "-", "--"
    ), NA_character_, .)) %>%
  rename_all( ~c(
    "var 1",
    "var 2")) %>%
  gather(2:ncol(.), key = "question", value = "values") %>%
  filter(!is.na(values)) %>%
  arrange(question, values)

# Mutate the data
df_numeric <- df %>%

  # Join area codes
  left_join(
    select(fi_postnumbers_2016, 1, 7), 
    by = "postinumero")) %>%
  
  # Strip information from social security number
  mutate_at(
    vars(hetu), 
    list(
      gender = ~calc_gender(.x), 
      birth_day = ~calc_birth(.x))) %>%
  
  # Calculate age
  mutate(age = interval(birth_day, today) / years(1)) %>%
  
  # Change statements to factors and remove EOS
  mutate_at(
    vars(1:3), 
    ~as.numeric(parse_factor(.x, l_statement, 
                             na = na_levels, include_na = FALSE))) %>%
  
  # Classify variablesage, pension amount and pension type
  mutate(
    var1 = cut(
      var, 
      c(0, 54.9, 59.9, 62.9, 64, 999), 
      labels = l_age),
    var2 = case_when(
      var %in% c("") ~ "case1",
      var %in% c("") ~ "case2",
      TRUE ~ var)) %>%

  # Generate 0-100 variables
  mutate_at(vars(1), ~ifelse(is.na(.x), 0, 100)) %>%
  mutate_at(vars(2), ~case_when(
    is.na(.x)     ~ NA_real_,
    .x == "Kyllä" ~ 100,
    TRUE          ~ 0)) %>%
  mutate_at(vars(3), ~case_when(
    is.na(.x)    ~ NA_real_,
    .x == "En"   ~ 0,
    TRUE         ~ 100)) %>%
                            
  # Calculate NPS
  mutate_at(vars(4), list(nps = ~calc_nps(.x))) %>%
  
  # Modify to factors with levels and custom NA values
  mutate_at(vars(5), ~parse_factor(.x, factor.levels, na = na_values)) %>%
  
  # To factors
  mutate_at(vars(6), ~as.factor(.x)) %>%
  
  # Leave only necessary variables
  select(NPS, 1:10)
  
```

```{r create-table, eval = FALSE}
# Create statistics table
# Choose data and columns to factor and group by
df_desc_raw <- desc_stat(
  df_numeric, 
  c(1:10), 
  c("var1", "var2"))
```

```{r mutate-table, eval = FALSE}
# Mutate statistics table
df_desc <- df_desc_raw %>%
  
  # Select columns
  select(1:2, one_of(l_unit, l_group2, l_group1)) %>%
  
  # Order rows
  mutate_at(vars(Variables), list(
    order = ~if_else(
      .x == "N",
      "0",
      str_replace_all(.x, "^x([0-9_]*)_.*", "\\1")),
    order2 = ~if_else(
      str_detect(.x, ":"), 
      str_replace_all(.x, ".*: ", ""), 
      "0"),
    order3 = ~if_else(str_detect(.x, "x[0-9]*_muu$"), 1, 0))) %>%
  mutate_at(
    vars(order, order2), 
    ~as.numeric(str_replace_all(.x, "_", "."))) %>%
  arrange(order, order2, order3, desc(total)) %>%
    
  # Recode Variables column
  left_join(desc_names, by = "Variables") %>%
  mutate_at(vars(Kysymys), ~if_else(
    is.na(.x), 
    str_replace_all(Variables, ".*: ", ""),
    .x)) %>%
  
  # Remove extra columns
  select(Kysymys, everything()) %>%
  select(-c(starts_with("order"), Variables)) %>%
  rename(`Yhteensä` = total)

```

```{r data-to-txt, eval = FALSE}
# Export data to txt-file
write_csv_fi(df_desc, path(d_out, "desc_table.txt"))
write_csv_fi(df_feedback, path(d_out, "data_feedback.txt"))
write_csv_fi(df, path(d_out, "data_cleaned_2018.txt"))
```

# Tiivistelmä

Yhteenveto ja johtopäätökset

# Tulokset

## Peruskuvat

```{r create-fig-basic, eval = FALSE}
# Basic plot
# Choose which variables to plot
l <- list(1, 2, c(3:5), 6, 7)

# Edit labels to fit the screen properly
labels <- c("var.name")

# Choose which variables to plot and map the function to a list
plot_basic <- df_desc %>% 
  select(1:2) %>%
  rename_at(1, ~str_sub(.x, 1, 30)) %>%
  {map(l, function(x) multiplot_bars(.x, x, labels))}

# Length of the list for a calculation to correct figure size
# Height of 6 for each row of pictures
len <- as.integer(round(length(plot_basic) / 2, 0) * 3)
```

```{r show-fig-basic, out.width = "100%", fig.height = len}
# Create and show a grid from plots
do.call("grid.arrange", c(plot_basic, ncol = 2))
```

## Tulostaulukko

```{r show-table, eval = FALSE}
# Show table
df_desc %>%
  mutate_at(vars(-1), ~round(.x, 1)) %>%
  mutate_at(vars(-1), ~if_else(is.na(.x), "", .x)) %>%
  datatable(rownames = FALSE, extensions = c("Buttons", "FixedColumns"), 
    options = list(
      pageLength = 10, 
      scrollX = TRUE, 
      lengthMenu = list(c(10, -1), list("10", "All")), 
      dom = "Blrtip", buttons = list(
        "copy",  
        list(
          extend = "excel", 
          filename = "Ilmarinen"), 
        list(
          extend = "colvis", 
          text = "Näytä/piilota sarakkeita", 
          columns = ":gt(1)", 
          show = ":lt(2)", 
          hide = ":gt(1)"), 
        list(
          extend = "colvisGroup", 
          text = "Piilota kaikki", 
          show = ":lt(2)", 
          hide = ":gt(1)"))))
```

### Sanapilvi

```{r wordcloud, out.width = "100%", eval = FALSE}
# Create wordcloud and give a random number seed
p_wordcloud <- path(d_out, "wordcloud.png")

set.seed(11102019)
plot_wordcloud(df_feedback$feedback, p_wordcloud, width = 9, height = 4)
knitr::include_graphics(p_wordcloud)
```

### Yksittäiset palautteet

```{r include = FALSE, eval = FALSE}
# This is needed for the feedback work
DT::datatable(df_feedback, extensions = "Buttons",
  options = list(
    pageLength = 5, scrollX = TRUE, dom = "Blrtip",
    buttons = list("copy", list(
      extend = "excel", filename = "Avopalaute"))))
```

```{r results = "asis", eval = FALSE}
# All feedback in its own boxes
for (i in unique(df_feedback$question)) {
  
  DT_i <- df_feedback %>%
    filter(question == i) %>%
    select(values)
  
  cat("\n\n")
  print(htmltools::tagList(
    DT::datatable(DT_i, 
      rownames = FALSE, 
      colnames = c(i), 
      extensions = "Buttons",
      options = list(
        pageLength = 5, scrollX = TRUE, dom = "Blrtip",
        lengthMenu = list(c(5, -1), list('5', 'All')),
        buttons = list("copy", list(
          extend = "excel", filename = "Avopalaute"))))))
  cat("\n\n")
}
```

```{r session-info}
sessionInfo()
```
